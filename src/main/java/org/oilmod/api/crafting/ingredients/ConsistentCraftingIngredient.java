package org.oilmod.api.crafting.ingredients;

import it.unimi.dsi.fastutil.ints.IntIterator;
import it.unimi.dsi.fastutil.ints.IntSortedSet;
import org.apache.commons.lang3.Validate;
import org.oilmod.api.rep.crafting.IComplexIngredient;
import org.oilmod.api.rep.crafting.IIngredient;
import org.oilmod.api.rep.crafting.IIngredientAccessor;
import org.oilmod.api.rep.crafting.IIngredientSupplier;
import org.oilmod.api.rep.itemstack.ItemStackConsumerRep;
import org.oilmod.api.rep.itemstack.ItemStackRep;
import org.oilmod.api.util.checkstate.ArrayState;
import org.oilmod.api.util.checkstate.ICheckState;
import org.oilmod.api.util.checkstate.StateHolderFactory;
import org.oilmod.api.util.checkstate.immutable.FlagState;
import org.oilmod.api.util.checkstate.immutable.ImmutableState;
import org.oilmod.api.util.checkstate.mutable.MutableIntState;
import org.oilmod.util.IntFixedRangeSet;

import java.util.List;
import java.util.function.IntPredicate;
import java.util.function.Supplier;

/**
 * Created by sirati97 on 04.07.2016 for OilMod-Api.
 */
public class ConsistentCraftingIngredient implements IComplexIngredient {
    private final IIngredient[] ingredients;



    @Override
    public Supplier<ItemStackRep> getExampleSupplier() {


        return null;
    }

    @Override
    public List<ItemStackRep> getExamples() {
        return null;
    }

    /*@Override
    public boolean check(IIngredientAccessor accessor, ICheckState checkState, int slotId, int slotCount, IntPredicate disclaimer, IntPredicate reclaimer) {
        checkState.requireMaxBackup(1);
        checkState.backupState();
        FlagState.FlagArrayState flags = checkState.getTag(this, FlagState.FACTORY_ARRAY);
        flags.assureCreated(ingredients.length);

        boolean foundAny = false;
        //IntStream.range(0, ingredients.length).mapToObj(flags::hasFlag).toArray(Boolean[]::new);
        for (int i = 0; i < ingredients.length; i++) {
            if (!flags.hasFlag(i)) {
                //first time or still active
                if (ingredients[i].check(accessor, checkState, slotId, slotCount, disclaimer, reclaimer)) {
                    foundAny = true;
                } else {
                    flags.setFlag(i); //this matcher is out
                }
            }
        }
        if (foundAny) { //yeah we save state for ingredients we dont use, really bad
            checkState.confirmState();
        } else {
            checkState.revertState();
        }
        return foundAny;
    }

    @Override
    public boolean confirmState(IIngredientSupplier supplier, IntSortedSet slots, int current, int needed, ICheckState checkState, IntPredicate disclaimer) {
        if (current < needed)return false;
        if (!checkState.hasTag(this))return false;
        FlagState.FlagArrayState flags = checkState.getTag(this, FlagState.FACTORY_ARRAY);
        if (!flags.isInUse()) return false;
        boolean found = false;

        for (int i = 0; i < ingredients.length; i++) {
            if (flags.hasFlag(i)) {
                if (found)return false;
                found = true;
            }
        }

        return found && current == needed;
    }

    @Override
    public int consume(IIngredientAccessor accessor, int slotId, ItemStackConsumerRep stackConsumer, int multiplier, ICheckState checkState, boolean simulate) {
        FlagState.FlagArrayState flags = checkState.getTag(this, FlagState.FACTORY_ARRAY);
        //here we are just using a previously written checkstate, it should already be valid!
        // this is a naive approach to verify it. if checkstate is partially created this will not catch it
        Validate.isTrue(flags.isInUse(), "Consume can only be called with a valid checkstate generated by consume");

        for (int i = 0; i < ingredients.length; i++) {
            if (flags.hasFlag(i))continue;
            return ingredients[i].consume(accessor, slotId, stackConsumer, multiplier, checkState, simulate);
        }

        throw new IllegalStateException("Either some of the ingredients were never matched, or most likely consume was called without a valid checkstate. make sure that ALL input categories are checked while given the same checkstate as this method to ensure proper initialisation of said");
    }*/

    @Override
    public boolean prepareRematch(ICheckState checkState) {
        ImmutableState<Data> dataContainer = checkState.getTag(this, FACTORY);
        if (!dataContainer.isInUse()) {
            return true;
        }

        if (dataContainer.get().ingreId >= 0) {
            dataContainer.get().ingreId = -1;
        }

        return true;
    }

    public static final StateHolderFactory<ImmutableState<Data>, Object> FACTORY = (currentBackup, maxBackup, key) -> new ImmutableState<>(Data.class);
    private static class Data {
        private final IntFixedRangeSet[] timesMatched;
        private final IntFixedRangeSet[] mapping;
        private int ingreId = -1;

        private Data(int ingre, int slotCount) {
            timesMatched = new IntFixedRangeSet[ingre];
            for (int i = 0; i < ingre; i++) {
                timesMatched[i] = new IntFixedRangeSet(slotCount, false);
            }
            mapping = new IntFixedRangeSet[slotCount];
        }
    }

    @Override
    public boolean check(IIngredientAccessor accessor, ICheckState checkState, int slotId, int slotCount, IntPredicate disclaimer, IntPredicate reclaimer) {
        ImmutableState<Data> dataContainer = checkState.getTag(this, FACTORY);
        if (!dataContainer.isInUse()) {
            dataContainer.set(new Data(ingredients.length, slotCount));
        }
        IntFixedRangeSet[] timesMatched = dataContainer.get().timesMatched;
        IntFixedRangeSet[] mappings = dataContainer.get().mapping;

        //we are already done
        if (dataContainer.get().ingreId >= 0) {
            return ingredients[dataContainer.get().ingreId].check(accessor, checkState, slotId, slotCount, disclaimer, reclaimer);
        }


        boolean found = false;
        //IntStream.range(0, ingredients.length).map(index -> flags.getOrCreateState(index).getOrDefault()).toArray();
        for (int i = 0; i < ingredients.length; i++) {
            if (ingredients[i].check(accessor, checkState, slotId, slotCount, disclaimer, reclaimer)) {
                timesMatched[i].add(slotId);
                IntFixedRangeSet mapping = mappings[slotId];
                if (mapping == null) {
                    mapping = new IntFixedRangeSet(ingredients.length, false);
                    mappings[slotId] = mapping;
                }
                mapping.add(i);
                found = true;
            }
        }
        return found;
    }

    @Override
    public boolean confirmState(IIngredientSupplier supplier, IntSortedSet slots, int current, int needed, ICheckState checkState, IntPredicate disclaimer) {
        if (current < needed)return false;
        if (!checkState.hasTag(this))return false;
        Data data = checkState.getTag(this, FACTORY).get();
        IntFixedRangeSet[] timesMatched = data.timesMatched;
        IntFixedRangeSet[] mappings = data.mapping;


        if (slots != null) {
            for (int i = 0; i < mappings.length; i++) {
                IntFixedRangeSet mapping = mappings[i];
                if (mapping == null)continue;
                if (!slots.contains(i)) { //we have that slot but apparently we are not allocated for it. remove
                    IntIterator iter = mapping.iterator();
                    while (iter.hasNext()) {
                        timesMatched[iter.nextInt()].remove(i);
                    }
                    mappings[i] = null;
                }
            }
        }
        int ingreId = -1;
        for (int i = 0; i < timesMatched.length; i++) {
            if (timesMatched[i].size() >= needed) {
                ingreId = i;
                break;
            }
        }
        if (ingreId == -1)return false;
        data.ingreId = ingreId;
        int found = 0;
        for (int i = 0; i < mappings.length; i++) {
            IntFixedRangeSet mapping = mappings[i];
            if (mapping == null)continue;
            if (found < needed && mapping.contains(ingreId)) {
                found++;
            } else {
                mappings[i] = null;
                if (!disclaimer.test(i)) return false;
            }
        }
        return found == needed;
    }

    @Override
    public int consume(IIngredientAccessor accessor, int slotId, ItemStackConsumerRep stackConsumer, int multiplier, ICheckState checkState, boolean simulate) {
        ImmutableState<Data> dataContainer = checkState.getTag(this, FACTORY);
        //here we are just using a previously written checkstate, it should already be valid!
        // this is a naive approach to verify it. if checkstate is partially created this will not catch it
        Validate.isTrue(dataContainer.isInUse(), "Consume can only be called with a valid checkstate generated by consume");
        int ingre = dataContainer.get().ingreId;
        if (ingre == -1)throw new IllegalStateException("confirmState was never called");
        return ingredients[ingre].consume(accessor, slotId, stackConsumer, multiplier, checkState, simulate);

        //throw new IllegalStateException("Either some of the ingredients were never matched, or most likely consume was called without a valid checkstate. make sure that ALL input categories are checked while given the same checkstate as this method to ensure proper initialisation of said");
    }





    /**
     * Use this class if you want to make specific slots of a shaped crafting recipe interchangeable. Create one instance of this and pass it for every interchangeable slot that should behave the same
     * @param ingredients Ingredients can be the following:<ul>
     *                    <li>Instances of IIngredient</li>
     *                    <li>Bukkit Material</li>
     *                    <li>Bukkit ItemStack</li>
     *                    <li>Class&lt;? extends OilItem&gt;</li>
     *                    <li>OilMod Item</li></ul>
     */
    /*public InterchangeableCraftingIngredient(Object... ingredients) {
        this(ItemCraftingFactory.toIIngredients(ingredients));
    }*/
    /**
     * Use this class if you want to make specific slots of a shaped crafting recipe interchangeable. Create one instance of this and pass it for every interchangeable slot that should behave the same
     */
    public ConsistentCraftingIngredient(IIngredient... ingredients) {
        this.ingredients = ingredients;
    }


    /*public ItemStackRep getRandomExample(Random rnd, DataHolder dataHolder) {
        ICIData data = dataHolder.get(this, factory);
        List<Integer> stillMissing = new ArrayList<>(data.getUnflaggedCount());
        for (int i = 0; i < ingredients.length; i++) {
            if (!data.getFlag(i)) {
                stillMissing.add(i);
            }
        }
        if (stillMissing.size() > 0) {
            int index = stillMissing.get(rnd.nextInt(stillMissing.size()));
            data.setFlag(index);
            return getRandomExampleChild(index, rnd, dataHolder);
        } else {
            throw createIllegalStateException();
        }
    }

    private ItemStackRep getRandomExampleChild(int i, Random rnd, DataHolder dataHolder) {
        IIngredient ingredient = ingredients[i];
        if (ingredient == null) {
            return null;
        } else {
            return ingredient.getRandomExample(rnd, dataHolder);
        }
    }

    @Override
    public ItemStackRep onCrafted(ItemStackRep oldItemStack, DataHolder dataHolder) {
        ICIData data = dataHolder.get(this, factory);
        for (int i = 0; i < ingredients.length; i++) {
            if (!data.getFlag(i)) {
                if (matchChild(i, oldItemStack, dataHolder)) {
                    data.setFlag(i);
                    return onCraftedChild(i, oldItemStack, dataHolder);
                }
            }
        }
        throw createIllegalStateException();
    }

    @Override
    public boolean matchesNull() {
        return true;
    }

    private ItemStackRep onCraftedChild(int i, ItemStackRep oldItemStack, DataHolder dataHolder) {
        IIngredient ingredient = ingredients[i];
        if (ingredient == null) {
            return oldItemStack;
        } else {
            return ingredient.onCrafted(oldItemStack, dataHolder);
        }
    }

    private IllegalStateException createIllegalStateException() {
        return new IllegalStateException((ingredients.length+1)+" random example was requested, but this InterchangeableCraftingIngredient only contains " + ingredients.length + " ingredients");
    }




    private static class ICIData {
        private final boolean[] flags;
        private int unflagged;

        private ICIData(int size) {
            this.flags = new boolean[size];
            this.unflagged = size;
        }

        public boolean getFlag(int i) {
            return flags[i];
        }

        public void setFlag(int i) {
            if (!getFlag(i)) {
                this.flags[i] = true;
                unflagged--;
            }
        }

        public int getUnflaggedCount() {
            return unflagged;
        }
    }

    private static class ICIDataFactory implements Factory<ICIData> {
        private final int size;

        private ICIDataFactory(int size) {
            this.size = size;
        }

        @Override
        public ICIData create() {
            return new ICIData(size);
        }
    }*/
}

package org.oilmod.api.crafting.ingredients;

import org.apache.commons.lang3.Validate;
import org.oilmod.api.rep.crafting.IIngredient;
import org.oilmod.api.rep.crafting.IIngredientAccessor;
import org.oilmod.api.rep.itemstack.ItemStackConsumerRep;
import org.oilmod.api.rep.itemstack.ItemStackRep;
import org.oilmod.api.util.checkstate.ArrayState;
import org.oilmod.api.util.checkstate.ICheckState;
import org.oilmod.api.util.checkstate.immutable.FlagState;
import org.oilmod.api.util.checkstate.immutable.ImmutableIntState;

import java.util.List;
import java.util.function.Supplier;
import java.util.stream.IntStream;

/**
 * Created by sirati97 on 04.07.2016 for OilMod-Api.
 */
public class ConsistentCraftingIngredient implements IIngredient {
    private final IIngredient[] ingredients;



    @Override
    public Supplier<ItemStackRep> getExampleSupplier() {


        return null;
    }

    @Override
    public List<ItemStackRep> getExamples() {
        return null;
    }

    @Override
    public boolean check(IIngredientAccessor accessor, ICheckState checkState, int slotId) {
        checkState.requireMaxBackup(1);
        checkState.backupState();
        FlagState.FlagArrayState flags = checkState.getTag(this, FlagState.FACTORY_ARRAY);
        flags.assureCreated(ingredients.length);

        boolean foundAny = false;
        //IntStream.range(0, ingredients.length).mapToObj(flags::hasFlag).toArray(Boolean[]::new);
        for (int i = 0; i < ingredients.length; i++) {
            if (!flags.hasFlag(i)) {
                //first time or still active
                if (ingredients[i].check(accessor, checkState, slotId)) {
                    foundAny = true;
                } else {
                    flags.setFlag(i); //this matcher is out
                }
            }
        }
        if (foundAny) { //yeah we save state for ingredients we dont use, really bad
            checkState.confirmState();
        } else {
            checkState.revertState();
        }
        return foundAny;
    }

    @Override
    public int consume(IIngredientAccessor accessor, int slotId, ItemStackConsumerRep stackConsumer, int multiplier, int maxStack, ICheckState checkState, boolean simulate) {
        FlagState.FlagArrayState flags = checkState.getTag(this, FlagState.FACTORY_ARRAY);
        //here we are just using a previously written checkstate, it should already be valid!
        // this is a naive approach to verify it. if checkstate is partially created this will not catch it
        Validate.isTrue(flags.isInUse(), "Consume can only be called with a valid checkstate generated by consume");

        for (int i = 0; i < ingredients.length; i++) {
            if (flags.hasFlag(i))continue;
            return ingredients[i].consume(accessor, slotId, stackConsumer, multiplier, maxStack, checkState, simulate);
        }

        throw new IllegalStateException("Either some of the ingredients were never matched, or most likely consume was called without a valid checkstate. make sure that ALL input categories are checked while given the same checkstate as this method to ensure proper initialisation of said");
    }

/*    @Override
    public boolean check(IIngredientAccessor accessor, ICheckState checkState, int slotId) {
        checkState.requireMaxBackup(1);
        checkState.backupState();
        ArrayState<MutableIntState> flags = checkState.getTag(this, MutableIntState.FACTORY_ARRAY);
        flags.assureCreated(ingredients.length);

        int currentMax = 0;
        int foundMax = 0;
        //IntStream.range(0, ingredients.length).map(index -> flags.getOrCreateState(index).getOrDefault()).toArray();
        for (int i = 0; i < ingredients.length; i++) {
            MutableIntState state = flags.getOrCreateState(i);
            if (ingredients[i].check(accessor, checkState, slotId)) {
                foundMax = Math.max(foundMax,  state.increment());
            }
            currentMax = Math.max(currentMax, state.getOrDefault());
        }
        if (foundMax <= maxMatch) {
            checkState.confirmState();
        } else {
            checkState.revertState();
        }
        return foundMax == currentMax && foundMax <= maxMatch;
    }

    @Override
    public int consume(IIngredientAccessor accessor, int slotId, ItemStackConsumerRep stackConsumer, int multiplier, int maxStack, ICheckState checkState, boolean simulate) {
        ArrayState<MutableIntState> flags = checkState.getTag(this, MutableIntState.FACTORY_ARRAY);
        //here we are just using a previously written checkstate, it should already be valid!
        // this is a naive approach to verify it. if checkstate is partially created this will not catch it
        Validate.isTrue(flags.isInUse(), "Consume can only be called with a valid checkstate generated by consume");

        int max = 0;
        int index = -1;
        for (int i = 0; i < ingredients.length; i++) {
            int state = flags.getOrCreateState(i).get();
            if (state > max) {
                index = i;
                max = state;
            }
        }

        if (index == -1 || max < maxMatch)return 0;

        return ingredients[index].consume(accessor, slotId, stackConsumer, multiplier, maxStack, checkState, simulate);

        //throw new IllegalStateException("Either some of the ingredients were never matched, or most likely consume was called without a valid checkstate. make sure that ALL input categories are checked while given the same checkstate as this method to ensure proper initialisation of said");
    }*/





    /**
     * Use this class if you want to make specific slots of a shaped crafting recipe interchangeable. Create one instance of this and pass it for every interchangeable slot that should behave the same
     * @param ingredients Ingredients can be the following:<ul>
     *                    <li>Instances of IIngredient</li>
     *                    <li>Bukkit Material</li>
     *                    <li>Bukkit ItemStack</li>
     *                    <li>Class&lt;? extends OilItem&gt;</li>
     *                    <li>OilMod Item</li></ul>
     */
    /*public InterchangeableCraftingIngredient(Object... ingredients) {
        this(ItemCraftingFactory.toIIngredients(ingredients));
    }*/
    /**
     * Use this class if you want to make specific slots of a shaped crafting recipe interchangeable. Create one instance of this and pass it for every interchangeable slot that should behave the same
     */
    public ConsistentCraftingIngredient(int toMatch,IIngredient... ingredients) {
        this.ingredients = ingredients;
    }


    /*public ItemStackRep getRandomExample(Random rnd, DataHolder dataHolder) {
        ICIData data = dataHolder.get(this, factory);
        List<Integer> stillMissing = new ArrayList<>(data.getUnflaggedCount());
        for (int i = 0; i < ingredients.length; i++) {
            if (!data.getFlag(i)) {
                stillMissing.add(i);
            }
        }
        if (stillMissing.size() > 0) {
            int index = stillMissing.get(rnd.nextInt(stillMissing.size()));
            data.setFlag(index);
            return getRandomExampleChild(index, rnd, dataHolder);
        } else {
            throw createIllegalStateException();
        }
    }

    private ItemStackRep getRandomExampleChild(int i, Random rnd, DataHolder dataHolder) {
        IIngredient ingredient = ingredients[i];
        if (ingredient == null) {
            return null;
        } else {
            return ingredient.getRandomExample(rnd, dataHolder);
        }
    }

    @Override
    public ItemStackRep onCrafted(ItemStackRep oldItemStack, DataHolder dataHolder) {
        ICIData data = dataHolder.get(this, factory);
        for (int i = 0; i < ingredients.length; i++) {
            if (!data.getFlag(i)) {
                if (matchChild(i, oldItemStack, dataHolder)) {
                    data.setFlag(i);
                    return onCraftedChild(i, oldItemStack, dataHolder);
                }
            }
        }
        throw createIllegalStateException();
    }

    @Override
    public boolean matchesNull() {
        return true;
    }

    private ItemStackRep onCraftedChild(int i, ItemStackRep oldItemStack, DataHolder dataHolder) {
        IIngredient ingredient = ingredients[i];
        if (ingredient == null) {
            return oldItemStack;
        } else {
            return ingredient.onCrafted(oldItemStack, dataHolder);
        }
    }

    private IllegalStateException createIllegalStateException() {
        return new IllegalStateException((ingredients.length+1)+" random example was requested, but this InterchangeableCraftingIngredient only contains " + ingredients.length + " ingredients");
    }




    private static class ICIData {
        private final boolean[] flags;
        private int unflagged;

        private ICIData(int size) {
            this.flags = new boolean[size];
            this.unflagged = size;
        }

        public boolean getFlag(int i) {
            return flags[i];
        }

        public void setFlag(int i) {
            if (!getFlag(i)) {
                this.flags[i] = true;
                unflagged--;
            }
        }

        public int getUnflaggedCount() {
            return unflagged;
        }
    }

    private static class ICIDataFactory implements Factory<ICIData> {
        private final int size;

        private ICIDataFactory(int size) {
            this.size = size;
        }

        @Override
        public ICIData create() {
            return new ICIData(size);
        }
    }*/
}
